#####################################################
#####################################################
############ Lexical Scoping assigment ##############
#####################################################
#####################################################

#The aim of this week's assigment is to learn about lexical scoping in R.
#R follows the environment tree structure, meaning that has different levels of environments that are 
#rooted to a final one called the empty environment.

##During the development of this assigment I have learned that there are differents environments,
#and the most important lesson I have adquired is that every single environment has a parent environment
#(except the emtpty environment).

#I have interiorised that R follows an order when looking for calling variables as followed:
#When a variable is requested inside a function, R would firstly search for it in the EVALUATION 
#ENVIRONMENT, meaning that it would look in the environment in which the function was defined.
#If the variable is not defined there, it would look into the parent environment, then the search
#continues down the sequence of parent environments until it hits the global environment, which is
#typically the userâ€™s workspace. Then, it will keep on searching in the package environment, then 
#package base environment untill it hits the Empty environment. If it hasn't found the called variable
# it would triggers an error message. 

##This week's task was to generate a function that creates a special matrix object that can get its 
#inverse. Also a second function that computes the inverse of the special matrix generated by the first 
#one and either retrieve the inverse of that matrix- if the inverse has already been calculated- or 
# calculate the inverse and set the value of the inverse in the cache.



######MATRIX THEORY.
###In order to get into the task's aim we should explore a bit about matrix .
###Matrix multiplication operation does not have the commutativity property, meaning that when you multiply 
#matrix A per matrix B is not the same as multiplying matrix B per matrix A.
#BUT, there is a matrix that would give the same result to the matrix product in both directions, and that 
#would be the inverse matrix.



## The following function would generate a special matrix. Secondly, we would create a second function that would retrieve or 
#populate the inverse of that special matrix that has been created by the first function.

##FIRST FUNTCION

makeCacheMatrix <- function(x = matrix()) { #We first set the x object as a matrix in the argument of the function
  i <- NULL  # We secondly set a second object, i, as NULL
  set <- function(y) {  ## Then we generates a function inside the function.
    x <<- y             ## Using the superassimgent operator we assign y to x in the parent environment.
    i <<- NULL          ## Using the superassimgent operator we assign the value NULL to i in the the parent environment.
  }
  get <- function() x  ## This part would get the value of the matrix x. Since we are using an anonymous function that
                       ## has not been previously defined, R would look for x in the parent environment wher it has already 
                       ## been defined
  setinverse <- function(solve) i <<- solve # Here, we would set the value of the inverse using solve() function, and we 
                                            # will assign the inverse as a value of i in the parent environment.  
  getinverse <- function() i  # Here we would get the value of the inverse.
  list(set = set, get = get,
       setinverse = setinverse,
       getinverse = getinverse)  ## Finally, this part will create a list including all four functions that we have generated
                                 ## and also it will assign a name for each function which corresponds to the name of the 
                                 ## function.
}


## SECOND FUNCTION

cacheSolve <- function(x, ...) {
  i <- x$getinverse()  ## It will first call the getinverse() function to check if the inverse has already been generated.
  if(!is.null(i)) {    ## If so, i will not be NULL and the result will be TRUE, this part would be activated and
    message("getting cached data")
    return(i)  ##the inverse would be returned.
  }
  data <- x$get()  #If not,i would be NULL and the result of that statement would FALSE and this part will be activated.
                   # and the inverse would need to be calculated. We first would get the object x using get() function.
  i <- solve(data, ...) 
  x$ setinverse(i) #Then using the setinverse() function we would calculate the inverse
  i                # and the result of i would be printed.
}



## In order to check that both function works we can run this:
#m1 is a 2:2 matrix
m1 <- matrix(c(1/2, -1/4, -1, 3/4), nrow = 2, ncol = 2)
m1
#n1 would be the inverse matrix of m1
n1 <- solve(m1)
n1

#We could manually check that n1 is the inverse of m1 and we get the same result when doing the product in both ways
product1 <- m1 %*% n1 
product2 <- n1 %*% m1

#We could check that both results are the same:
product1 == product2

###So, we should obtain the same result when using the functions we have create:
myMatrix_object <- makeCacheMatrix(m1)
inverseMatrix <- cacheSolve(myMatrix_object)
inverseMatrix

#To check that the matrix we get is the same as the one we obtain manually we could do:
inverseMatrix == n1

#And also check that the matrix obtein by multiplying the matrix per the inverse is the same
m1 %*% inverseMatrix
inverseMatrix %*% m1





